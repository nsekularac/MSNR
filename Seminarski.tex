% !TEX encoding = UTF-8 Unicode

\documentclass[a4paper]{article}

\usepackage{color}
\usepackage{url}
\usepackage[T2A]{fontenc} % enable Cyrillic fonts
\usepackage[utf8]{inputenc} % make weird characters work
\usepackage{graphicx}
\usepackage{physics}

\usepackage[english,serbian]{babel}
%\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

\usepackage[unicode]{hyperref}
\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

%\newtheorem{primer}{Пример}[section] %ćirilični primer
\newtheorem{primer}{Primer}[section]

\begin{document}

\title{Kvantno računarstvo 2 (funkcionalni programski jezici za kvantno programiranje)\\ \small{Seminarski rad u okviru kursa\\Metodologija stručnog i naučnog rada\\ Matematički fakultet}}

\author{Aleksandar Ćurković, Nemanja Šekularac\\ curkovical@gmail.com, nemanja.sekularac@gmail.com}
\date{14.~april 2015.}
\maketitle

\abstract{
U ovom radu prikazujemo funkcionalne programske jezike za kvantno programiranje, uz kratak osvrt na osnove kvantnog računarstva i funkcionalne programske jezike uopšte.
Propratni primeri realizovani su u programskom jeziku Quipper.

\tableofcontents

\newpage

\section{Uvod}
\label{sec:uvod}

\subsection{Kvantno računarstvo}
\label{sec:kvantnoracunarstvo}

Kvantno računarstvo je oblast istraživanja koja se bavi računarskim sistemima koji u svom radu direktno koriste efekte kvantne mehanike.
Kvantni efekti, kao što su superpozicija (eng.~\em{superposition}) i kvantna zapletenost (eng. ~\em{quantum entanglement}) se u ovim sistemima, koje nazivamo kvantnim računarima tretiraju kao resurs i koriste za izvršavanje operacija nad podacima.

\subsection{Osnovni pojmovi kvantnog računarstva}

\subsubsection {Kjubit}

Kjubit (eng.~\emph{qubit, quantum bit}) je najmanja jedinica izračunavanja u kvantnom računarstvu.

Kjubit je pandan jednom bitu informacija u klasičnom računarstvu, ali dok se jedan bit može naći u 2 diskretna stanja (0, 1),
kjubit, na osnovu kvantnog principa superpozicije može istovremeno biti u oba.
Tačnije, stanje kjubita, u odsustvu merenja, može biti bilo koja linearna kombinacija osnovnih stanja.
Za osnovna stanja (eng. ~\em base states). kjubita se uzimaju ona koja pri merenju prelaze u stanje 0 ili 1 sa verovatnoćom 1 i obeležavaju se sa $\ket{1}$ i $\ket{0}$

Formalno, stanje kjubita se zapisuje kao $\alpha \ket{0} + \beta \ket{1}$ gde su $\alpha i \beta$ \em{kompleksni} parametri koji označavaju verovatnoću da se nakon merenja (očitavanja stanja) kjubit nađe u jednom od osnovnih stanja sa verovatnoćama, redom, $\alpha^2$ i $\beta^2$ i važi $\alpha^2+\beta^2=1$

Ovo svojstvo ima za posledicu da se 2 kubita mogu naći istovremeno u 4 različita stanja i generalno, n kubita može odjednom biti u $2^n$ različitih stanja.

Skup kjubita uzetih zajedno naziva se kvantni registar. (eng.~\emph{quantum register}).

\subsubsection{Zapletenost, kombinovanje kjubita, kvantni paralelizam}
\label{entanglement}

Efekat kvantne zapletenosti se manifestuje visoko koreliranim stanjima zapletenih čestica nakon merenja.
To nam omogućava da kombinujemo kjubite na način na koji to nije moguće sa bitovima. Stanje sistema od 2 zapletena kjubita predstavlja se kao linearna kombinacija svih kombinacija osnovnih stanja oba elementa.\\

$\alpha\ket{00} + \beta\ket{01} + \gamma\ket{10} + \delta\ket{11}$\\

pri čemu su $\alpha^2, \beta^2, \gamma^2, \delta,$ redom verovatnoće da će se sistem naći u odgovarajućoj kombinaciji osnovnih stanja gde i dalje važi\\

$\alpha^2+\beta^2+\gamma^2+\delta^2=1$

Ovo nam omogućava da, u teoriji, funkcije na kvantnim računarima evaluiramo za više vrednosti \emph{odjednom} tako što vrednosti zadamo u terminima parametara zapletenog sistema. Ovaj efekat, kvantni paralelizam (eng.~\emph{quantum parallelism}) suštinski odvaja kvantno od klasičnog računarstva.

Nažalost, ovo funkcioniše samo dok je sistem u stanju koherencije  tj dok su superpozicija i spletenost očuvani.

\subsubsection {Operacije nad kjubitima, kvantne kapije}

Zbog očuvanja koherencije sistema i informacija u toku izvršenja, sve operacije nad kjubitima i sistemima kjubita moraju biti reverzibilne (eng.~\emph{reversible}).

Formalno ove operacije predstavljamo unitarnim operatorima nad izabranim prostorom stanja sistema.

Kvantna logička kapija (eng. ~\emph{quantum logic gate}) je kvantni pandan logičkoj kapiji klasičnog računarstva i predstavlja jednu takvu operaciju.

Posebno su nam, kao i u klasičnom računarstvu, zanimljive male kvantne logičke kapije koje mogu da svojom kombinacijom predstavljaju druge operacije ( ili da ih barem proizvoljno približno aproksimiraju sa konačnim brojem osnovnih kapija). Jedan takav \emph{univerzalni set kapija} su na primer Hadamardova kapija (eng~\emph{Hadamard gate})\\
\smallskip
$H\equiv\frac{1}{\sqrt{2}}\begin{pmatrix}
1&1\\
-1&1
\end{pmatrix}$\\
\smallskip
koja radi nad jednim kjubitom na sledeći način:\\
\smallskip
$\ket{0} \rightarrow \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$\\
\smallskip
$\ket{1} \rightarrow \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$\\

i Toffoli kapija (eng.~\emph{Toffoli gate}) (Toffoli je reverzibilna logička kapija u klasičnom računarstvu i može se predstaviti u kvantnom obliku).

Detaljnije informacije o osnovama kvantnog računarstva mogu se naći npr. u \cite{knjiga}

\subsubsection{Kvantno kolo, Kvantni algoritam, Modeli kvantnog računara}
\label{modeli}

Kvantno kolo je sekvenca kvantnih kapija kao osnovnih operacija koje vrše transformacije nad jednim ili više kjubita. Samo kvantno kolo predstavlja jednu unitarnu operaciju (kao kombinacija unitarnih operacija/kapija)

Da bi smo kvantno kolo upotrebili za izračunavanje potrebno je sistem na koji je primenjeno najpre inicijalizovati na nek početne vrednosti.

Da bi smo rezultat izračunavanja vratili u klasični računar potrebno nam je merenje. U kvantnoj mehanici merenje je nereverzibilna, destruktivna operacija koja sistem dovodi u stanje dekoherencije.

Takođe merenje je probabilistička operacija (kvantni računari dele osobine sa probabilističkim i nedeterminističkim računarima i rešenje daju samo sa određenom tačnošću).

To dovodi do toga da je opšti upotrebljivi kvantni algoritam niz uzastopnih inicijalizacija, primenjenih kvantnih kola i merenja sa dodatim klasičnim operacijama (npr provere rezultata ili kontrole toka).

Praktična konstrukcija kvantnog računara je još uvek u domenu laboratorijskih eksperimenata uz tek poneki komercijalni pokušaj.

Za potrebe kvantnog računarstva, sisteme predstavljamo različitim idealizovanim modelima kao što su npr kvantna Turingova mašina (eng.~\emph{quantum Turing machine, QTM}) ili kvantno kolo (eng. ~\emph{quantum circuit}) dok zanemarujemo prisustvo greške i efekte smetnji (eng.~\emph{interference}) i dekoherencije koji su realnost kvantnih računara.

Neki od opisanih funkcionalnih jezika (Quipper, ?) rade na modelu kvantne memorije sa nasumičnim pristupom (eng.~\emph{Quantum Random Access Memory, Quantum RAM, QRAM} opisan u \cite{qram_model}

Kvantni računar je zamišljen kao koprocesor povezan sa klasičnim računarom na kome se izvršava kontrola toka. Kvantni uređaj sadrži fiksni unapred određeni broj kjubita i sposoban je da ih individualno adresira. Na kvantnom računaru se izvršavaju samo 2 tipa operacija, unitarne operacije i merenja.  Smatra se da je određen broj osnovnih unitarnih operacija realizovan kroz ugrađenje kvantne kapije i da su one oblika "Primeni ugrađenu operaciju na određene kjubite". Ove operacije vraćaju potvrdu kvantnog računara o izvršenju ali ne i bilo kakvu drugu informaciju.

Informacije o rezultatu se dobijaju operacijama merenja, oblika "izmeri kjubit q", ova operacija vraća 0 ili 1 klasičnom računaru sa određenim verovatnoćama.

\subsection{Funkcionalni programski jezici}
\label{sec:funkcionalniprgjezici}

Funkcionalno programiranje je programska paradigma u kojoj je osnovni način izračunavanja primena funkcija na argumente. Funkcionalni programski jezici su jezici koji podržavaju i ohrabruju primenu funkcionalne paradigme. Tradicionalni programski jezici se baziraju na ideji varijable kao promenljive veze izmedju imena i vrednosti. Ovi jezici se nazivaju imperativni jer se sastoje od niza komandi, koje čine dodele koje menjaju vrednost varijable. Funkcionalni jezici se baziraju na strukturiranim pozivima funkcija. Funkcionalni program se sastoji od poziva funkcije koja može da poziva druge funkcije: 
    <function1>(<function2>(<function3> ... ) ... ))

Medju najbitnijim konceptima funkcionalnog programiranja su funkcije višeg reda i odsustvo nus-pojava. 
Funkcije višeg reda su funkcije koje ili mogu za argumente uzeti druge funkcije ili kao svoj rezultat vraćaju funkciju, čime se omogućavaju ugnježđeni pozivi funkcija, odn. pojava koje se zove kompozicija funkcija.
Eliminacija nus-pojava podrazumeva otklanjanje svih promena koje ne zavise od pozvane funkcije i njenih argumenata, tako da više poziva jedne funkcije uvek vraća isti rezultat ako su argumenti poziva isti. Eliminacijom nus-pojava olakšava se razumevanje programa i formalna verifikacija a redosled izvršavanja postaje nebitan(ref).
Prvi i dugo vremena najpopularniji funkcionalni programski jezik je Lisp (LISt Processor) nastao 1958. pod uticajem lamda računa, ali 
zadržavajući dodelu vrednosti promenljivoj. Glavna struktura podataka u Lisp-u je povezana lista. Prvi čisti funkcionalni jezik 
(bez dodele vrednosti promenljivoj) je ISWIM. Još neki bitni f. jezici su Erlang, Haskell, ML, Scala, F# itd.

\section{Funkcionalni programski jezici za kvantno programiranje}
\label{sec:funcprl_qp}


\subsection{Quantum Lambda Calculus}
\label{sec:lambdacalc}


\subsection{QFC and QPL}
\label{sec:qfc_qml}

QFC, QPL

\subsection{QML}
\label{sec:qml}

QML

\subsection{Quipper}
\label{sec:quipper}

Quipper je skalabilni (eng.~\emph{scalable}), ekspresivni, funkcionalni programski jezik višeg nivoa (eng.~ \emph{higher-order}).
Prvi put predstavljen 2013. godine u \cite{quipper_language}.

\subsubsection{Model}

Quipper kao model kvantnog računara koristi QRAM model kratko opisan u \ref{modeli}, detaljno u \cite{qram_model} 


\subsubsection{Odlike jezika}

Prošireni model kola - osim unitarnih kapija/kola quipper obezbeđuje ugrađenu podršku za eksplicitnu inicijalizaciju i prekid (eng.~\emph{termination}), merenja, klasične bitove, klasične kapije i klasično-kontrolisane kvantne kapije 

Pomoćni kjubiti (eng.~\emph{ancilliary qubits, ancillas}) - dopunski ulazi koji su potrebni za neke kvantne algoritme (npr. pretpostavlja se da su u stanju $\ket{0}$ pre i posle izvršenja), eksplicitna inicijalizacija i prekid omogućavaju kontrolu opsega (eng.~\emph{scope})

Prekidanje sa potvrdom (eng.~\emph{assertive termination}) - operacija koja "dealocira" kjubit uz potvrdu da je u stanju $\ket{0}$\\

Mešana klasično/kvantna kola - klasični bitovi, klasične kapije i klasično kontrolisane kvantne kapije se mogu slobodno kombinovati sa čisto kvantnim kapijama.

\subsubsection{Faze izvršenja}

Faza kompilacije\\
Izvršava se na klasičnom računaru, rezultat je objektni izvršni kod, ulaz je izvorni kod i parametri koji se zadaju u fazi kompilacije (eng.~\emph{compile time parameters}

Faza generisanja kola (eng.~\emph{circuit generation})\\
Izvršava se na klasičnom računaru u vreme izvršenja koda, ulaz je izvršni kod i parametri kola (eng.~\emph{circuit parameters} (veličine registara, veličine problema, veličina vremenskih koraka, pragovi greške i slično)

Faza izvršenja kola\\
Izvršava se na kvantnom računaru, ulaz je kvantno kolo generisano u drugoj fazi i ulazni parametri kola (ulazni klasični bitovi (za klasične delove mešanih kola) ili ako fizička implementacija podržava, učitani kjubiti kao ulazi kvantnog kola). Izlaz je izlaz izvršenog kola (klasični bitovi dobijeni merenjem, ako je podržano kjubiti koji treba da budu sačuvani)

Uobičajeni model kvantnog izračunavanja uključuje kombinovanje druge i treće faze, klasični računar snima i obrađuje rezultate izvršenja kola, generiše novo kolo, izvršava ga itd. Quipper takođe podržava opštiji model, da se izlaz jednog kola može koristiti kao parametar za generisanje drugog, pod pretpostavkom da je kvantni deo sistema sposoban da čuva kjubite između izvršenja kola.

\subsubsection{Parametri i ulazi}

Quipper pravi razliku između parametara poznatih pri generisanju kola i parametara poznatih samo pri izvršenju. Ovi poslednji nazivaju se ulazi (eng.~\emph{inputs}). Ova podela je prenesena na tipove u jeziku pa imamo \emph{Bool} - logička promenljiva poznata u fazi generisanja kola i \emph{Bit} - jednobitni logički ulaz u klasično kolo i \emph{Qubit} - 1-kjubitni ulaz u kvantno kolo

Ova razlika se prenosi i na klasične tipove podataka, npr. celobrojne parametre i celobrojne ulaze.

Poseban termin, oblik podataka(eng.~\emph{shape of data}) koristi se za osobine podataka koje se u fazi generisanja kola uzimaju kao parametarske. Na primer, dužina niza je celobrojni parametar koji određuje neku veličinu pri generisanju kola a njegov sadržaj su kjubitni ulazi.

\subsubsection{Jezik za opis kola}

//TODO


\subsubsection{Izvršavanje na klasičnim računarima}
\label{sec:quipperizvrsavanje}

Quipper je realizovan kao ~\em embedded ~\em language u okviru funkcionalnog jezika Haskell sa dodatnim bibliotekama. Aktuelna distribucija sadrži i simulator kvantnog računara i kod pisan u quipperu se može, naravno neefikasno, izvršiti i na klasičnim računarima.

\subsection{Primeri}

Primeri u prilogu demonstriraju osnovne osobine jezika Quipper, urađeni su uz pomoć \cite{quipper_programming_intro}.

Uputstvo za pokretanje

\subsubsection{Primer1}
Opis primera 1
ime datoteke1
\subsubsection{Primer2}
Opis primera 2
ime datoteke2
\subsubsection{Primer3}
Opis primera 3
ime datoteke3

\section{Zaključak}
\label{sec:zakljucak}




\addcontentsline{toc}{section}{Literatura}
\appendix
\bibliography{seminarski} 
\bibliographystyle{plain}


\end{document}
